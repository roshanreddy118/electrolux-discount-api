{
    "sourceFile": "discount/app/src/main/kotlin/io/nexure/discount/repository/ProductRepository.kt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1769775283705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1769775283705,
            "name": "Commit-0",
            "content": "package io.nexure.discount.repository\n\nimport io.nexure.discount.database.ProductDiscounts\nimport io.nexure.discount.database.Products\nimport io.nexure.discount.model.Discount\nimport io.nexure.discount.model.Product\nimport org.jetbrains.exposed.exceptions.ExposedSQLException\nimport org.jetbrains.exposed.sql.*\nimport org.jetbrains.exposed.sql.transactions.transaction\nimport java.math.BigDecimal\n\n/**\n * Repository for managing product data with PostgreSQL backend\n * Implements concurrency-safe operations for discount application\n */\nclass ProductRepository {\n    \n    /**\n     * Find all products for a specific country\n     * @param country Country to filter products by\n     * @return List of products in the specified country with their discounts\n     */\n    fun findByCountry(country: String): List<Product> = transaction {\n        // Join products with their discounts in a single query for efficiency\n        val productDiscountPairs = (Products leftJoin ProductDiscounts)\n            .selectAll()\n            .where { Products.country eq country }\n            .orderBy(Products.id)\n        \n        // Group results by product to build the discount lists\n        val productsWithDiscounts = productDiscountPairs\n            .groupBy { it[Products.id] }\n            .map { (productId, rows) ->\n                val firstRow = rows.first()\n                val discounts = rows.mapNotNull { row ->\n                    row.getOrNull(ProductDiscounts.discountId)?.let { discountId ->\n                        Discount(\n                            discountId = discountId,\n                            percent = row[ProductDiscounts.percent].toDouble()\n                        )\n                    }\n                }\n                \n                Product(\n                    id = productId,\n                    name = firstRow[Products.name],\n                    basePrice = firstRow[Products.basePrice].toDouble(),\n                    country = firstRow[Products.country],\n                    discounts = discounts\n                )\n            }\n        \n        productsWithDiscounts\n    }\n    \n    /**\n     * Find a single product by its ID\n     * @param productId The product ID to search for\n     * @return Product if found, null otherwise\n     */\n    fun findById(productId: String): Product? = transaction {\n        val productDiscountPairs = (Products leftJoin ProductDiscounts)\n            .selectAll()\n            .where { Products.id eq productId }\n        \n        val rows = productDiscountPairs.toList()\n        if (rows.isEmpty()) return@transaction null\n        \n        val firstRow = rows.first()\n        val discounts = rows.mapNotNull { row ->\n            row.getOrNull(ProductDiscounts.discountId)?.let { discountId ->\n                Discount(\n                    discountId = discountId,\n                    percent = row[ProductDiscounts.percent].toDouble()\n                )\n            }\n        }\n        \n        Product(\n            id = firstRow[Products.id],\n            name = firstRow[Products.name],\n            basePrice = firstRow[Products.basePrice].toDouble(),\n            country = firstRow[Products.country],\n            discounts = discounts\n        )\n    }\n    \n    /**\n     * Apply a discount to a product with idempotency and concurrency safety\n     * Uses database unique constraint to prevent duplicate discount applications\n     * @param productId The product to apply discount to\n     * @param discount The discount to apply\n     * @return true if discount was applied, false if it already existed\n     * @throws IllegalArgumentException if product doesn't exist\n     * @throws RuntimeException for other database errors\n     */\n    fun applyDiscount(productId: String, discount: Discount): Boolean = transaction {\n        // First verify the product exists\n        val productExists = Products.selectAll().where { Products.id eq productId }.count() > 0\n        if (!productExists) {\n            throw IllegalArgumentException(\"Product with ID '$productId' not found\")\n        }\n        \n        try {\n            // Attempt to insert the discount\n            // The unique constraint on (product_id, discount_id) will prevent duplicates\n            ProductDiscounts.insert {\n                it[this.productId] = productId\n                it[this.discountId] = discount.discountId\n                it[this.percent] = BigDecimal.valueOf(discount.percent)\n            }\n            true // Successfully inserted new discount\n        } catch (e: ExposedSQLException) {\n            // Check if this is a unique constraint violation (discount already exists)\n            // Support both PostgreSQL and H2 error messages\n            val errorMessage = e.message?.lowercase() ?: \"\"\n            if (errorMessage.contains(\"duplicate key value violates unique constraint\") ||\n                errorMessage.contains(\"unique constraint\") ||\n                errorMessage.contains(\"unique index or primary key violation\")) {\n                false // Discount already exists - idempotent behavior\n            } else {\n                throw RuntimeException(\"Database error while applying discount: ${e.message}\", e)\n            }\n        }\n    }\n    \n    /**\n     * Create a new product in the database\n     * @param product The product to create\n     */\n    fun create(product: Product): Unit = transaction {\n        Products.insert {\n            it[id] = product.id\n            it[name] = product.name\n            it[basePrice] = BigDecimal.valueOf(product.basePrice)\n            it[country] = product.country\n        }\n        \n        // Insert any existing discounts\n        product.discounts.forEach { discount ->\n            ProductDiscounts.insert {\n                it[productId] = product.id\n                it[discountId] = discount.discountId\n                it[percent] = BigDecimal.valueOf(discount.percent)\n            }\n        }\n    }\n    \n    /**\n     * Get all products (for testing/admin purposes)\n     * @return List of all products with their discounts\n     */\n    fun findAll(): List<Product> = transaction {\n        val productDiscountPairs = (Products leftJoin ProductDiscounts)\n            .selectAll()\n            .orderBy(Products.id)\n        \n        val productsWithDiscounts = productDiscountPairs\n            .groupBy { it[Products.id] }\n            .map { (productId, rows) ->\n                val firstRow = rows.first()\n                val discounts = rows.mapNotNull { row ->\n                    row.getOrNull(ProductDiscounts.discountId)?.let { discountId ->\n                        Discount(\n                            discountId = discountId,\n                            percent = row[ProductDiscounts.percent].toDouble()\n                        )\n                    }\n                }\n                \n                Product(\n                    id = productId,\n                    name = firstRow[Products.name],\n                    basePrice = firstRow[Products.basePrice].toDouble(),\n                    country = firstRow[Products.country],\n                    discounts = discounts\n                )\n            }\n        \n        productsWithDiscounts\n    }\n}"
        }
    ]
}
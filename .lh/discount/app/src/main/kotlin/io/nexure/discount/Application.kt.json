{
    "sourceFile": "discount/app/src/main/kotlin/io/nexure/discount/Application.kt",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1769775284331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1769775284331,
            "name": "Commit-0",
            "content": "package io.nexure.discount\n\nimport io.ktor.http.*\nimport io.ktor.serialization.kotlinx.json.*\nimport io.ktor.server.application.*\nimport io.ktor.server.engine.*\nimport io.ktor.server.netty.*\nimport io.ktor.server.plugins.contentnegotiation.*\nimport io.ktor.server.plugins.statuspages.*\nimport io.ktor.server.request.*\nimport io.ktor.server.response.*\nimport io.ktor.server.routing.*\nimport io.nexure.discount.database.DatabaseConfig\nimport io.nexure.discount.model.ApplyDiscountRequest\nimport io.nexure.discount.model.Discount\nimport io.nexure.discount.model.ApplyDiscountResponse\nimport io.nexure.discount.repository.ProductRepository\nimport io.nexure.discount.service.DataSeedingService\nimport io.nexure.discount.service.PriceCalculationService\nimport io.nexure.discount.service.VatService\nimport kotlinx.serialization.json.Json\n\nconst val DISCOUNT_ENDPOINT = \"/discount\"\n\nfun main() {\n    embeddedServer(\n        factory = Netty,\n        port = 8082,\n        host = \"0.0.0.0\",\n        module = Application::module,\n    ).start(true)\n}\n\nfun Application.module() {\n    // Initialize database connection only if not already initialized (for tests)\n    try {\n        DatabaseConfig.init()\n    } catch (e: Exception) {\n        // Database might already be initialized by tests, ignore\n        environment.log.info(\"Database already initialized or initialization failed: ${e.message}\")\n    }\n    \n    // Don't seed database if products already exist (prevents test interference)\n    val productRepository = ProductRepository()\n    try {\n        val existingProducts = productRepository.findAll()\n        if (existingProducts.isEmpty()) {\n            DataSeedingService.seedDatabase(productRepository)\n        }\n    } catch (e: Exception) {\n        environment.log.warn(\"Failed to check or seed database: ${e.message}\")\n    }\n    \n    // Configure JSON serialization for API responses\n    install(ContentNegotiation) {\n        json(Json {\n            prettyPrint = true\n            isLenient = true\n            ignoreUnknownKeys = true\n        })\n    }\n    \n    // Configure error handling with proper HTTP status codes\n    install(StatusPages) {\n        exception<IllegalArgumentException> { call, cause ->\n            call.respond(HttpStatusCode.BadRequest, mapOf(\"error\" to cause.message))\n        }\n        exception<Throwable> { call, cause ->\n            call.respond(HttpStatusCode.InternalServerError, mapOf(\"error\" to \"Internal server error\"))\n        }\n    }\n    \n    routing()\n}\n\nfun Application.routing() {\n    val productRepository = ProductRepository()\n    \n    routing {\n        /**\n         * GET /products?country={country}\n         * Returns all products for the given country with calculated final prices\n         */\n        get(\"/products\") {\n            val country = call.request.queryParameters[\"country\"]\n            \n            if (country.isNullOrBlank()) {\n                call.respond(\n                    HttpStatusCode.BadRequest, \n                    mapOf(\"error\" to \"Country parameter is required\")\n                )\n                return@get\n            }\n            \n            // Validate that the country is supported for VAT calculation\n            if (!VatService.isCountrySupported(country)) {\n                call.respond(\n                    HttpStatusCode.BadRequest,\n                    mapOf(\n                        \"error\" to \"Unsupported country: $country\",\n                        \"supportedCountries\" to VatService.getSupportedCountries()\n                    )\n                )\n                return@get\n            }\n            \n            try {\n                val products = productRepository.findByCountry(country)\n                val productResponses = products.map { product ->\n                    PriceCalculationService.toProductResponse(product)\n                }\n                \n                call.respond(HttpStatusCode.OK, productResponses)\n            } catch (e: Exception) {\n                call.respond(\n                    HttpStatusCode.InternalServerError, \n                    mapOf(\"error\" to \"Failed to retrieve products: ${e.message}\")\n                )\n            }\n        }\n        \n        /**\n         * PUT /products/{id}/discount\n         * Applies a discount to a product with idempotency and concurrency safety\n         */\n        put(\"/products/{id}/discount\") {\n            val productId = call.parameters[\"id\"]\n            \n            if (productId.isNullOrBlank()) {\n                call.respond(\n                    HttpStatusCode.BadRequest, \n                    mapOf(\"error\" to \"Product ID is required\")\n                )\n                return@put\n            }\n            \n            try {\n                val discountRequest = call.receive<ApplyDiscountRequest>()\n                \n                // Validate discount request\n                if (discountRequest.discountId.isBlank()) {\n                    call.respond(\n                        HttpStatusCode.BadRequest, \n                        mapOf(\"error\" to \"Discount ID cannot be empty\")\n                    )\n                    return@put\n                }\n                \n                if (discountRequest.percent <= 0 || discountRequest.percent > 100) {\n                    call.respond(\n                        HttpStatusCode.BadRequest, \n                        mapOf(\"error\" to \"Discount percent must be between 0 (exclusive) and 100 (inclusive)\")\n                    )\n                    return@put\n                }\n                \n                val discount = Discount(\n                    discountId = discountRequest.discountId,\n                    percent = discountRequest.percent\n                )\n                \n                // Apply discount with concurrency safety\n                val discountApplied = productRepository.applyDiscount(productId, discount)\n                \n                if (discountApplied) {\n                    // Fetch updated product to return with new final price\n                    val updatedProduct = productRepository.findById(productId)\n                    if (updatedProduct != null) {\n                        val productResponse = PriceCalculationService.toProductResponse(updatedProduct)\n                        call.respond(\n                            HttpStatusCode.OK, \n                            ApplyDiscountResponse(\n                                message = \"Discount applied successfully\",\n                                product = productResponse\n                            )\n                        )\n                    } else {\n                        call.respond(HttpStatusCode.NotFound, mapOf(\"error\" to \"Product not found\"))\n                    }\n                } else {\n                    // Discount already exists - idempotent response\n                    val existingProduct = productRepository.findById(productId)\n                    if (existingProduct != null) {\n                        val productResponse = PriceCalculationService.toProductResponse(existingProduct)\n                        call.respond(\n                            HttpStatusCode.OK, \n                            ApplyDiscountResponse(\n                                message = \"Discount already applied\",\n                                product = productResponse\n                            )\n                        )\n                    } else {\n                        call.respond(HttpStatusCode.NotFound, mapOf(\"error\" to \"Product not found\"))\n                    }\n                }\n                \n            } catch (e: IllegalArgumentException) {\n                call.respond(HttpStatusCode.NotFound, mapOf(\"error\" to e.message))\n            } catch (e: Exception) {\n                call.respond(\n                    HttpStatusCode.InternalServerError, \n                    mapOf(\"error\" to \"Failed to apply discount: ${e.message}\")\n                )\n            }\n        }\n        \n        /**\n         * GET /health\n         * Health check endpoint for monitoring\n         */\n        get(\"/health\") {\n            call.respond(HttpStatusCode.OK, mapOf(\"status\" to \"healthy\"))\n        }\n    }\n}\n"
        }
    ]
}
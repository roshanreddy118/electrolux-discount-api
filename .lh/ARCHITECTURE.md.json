{
    "sourceFile": "ARCHITECTURE.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1769774956643,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1769774978653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,4 +249,5 @@\n 2. **Database Indexes**: Unique constraint serves dual purpose (integrity + performance)\n 3. **Transaction Isolation**: ACID compliance ensures data consistency\n 4. **Error Handling**: Graceful degradation with proper HTTP status codes\n 5. **Testing**: TestContainers ensure database behavior matches production\n+![alt text](Mermaid_1.png)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1769774985026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,5 +249,7 @@\n 2. **Database Indexes**: Unique constraint serves dual purpose (integrity + performance)\n 3. **Transaction Isolation**: ACID compliance ensures data consistency\n 4. **Error Handling**: Graceful degradation with proper HTTP status codes\n 5. **Testing**: TestContainers ensure database behavior matches production\n-![alt text](Mermaid_1.png)\n\\ No newline at end of file\n+\n+![alt text](Mermaid_1.png)\n+\n"
                },
                {
                    "date": 1769774992361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -252,4 +252,5 @@\n 5. **Testing**: TestContainers ensure database behavior matches production\n \n ![alt text](Mermaid_1.png)\n \n+![alt text](Mermaid_2.png)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1769775015375,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -250,7 +250,7 @@\n 3. **Transaction Isolation**: ACID compliance ensures data consistency\n 4. **Error Handling**: Graceful degradation with proper HTTP status codes\n 5. **Testing**: TestContainers ensure database behavior matches production\n \n-![alt text](Mermaid_1.png)\n \n+\n ![alt text](Mermaid_2.png)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1769775034942,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,8 +168,10 @@\n \n     Note over Client1, Client2: Both clients get success response<br/>but discount applied only once\n ```\n \n+![alt text](Mermaid_1.png)\n+\n ## Database Schema\n \n ### Tables\n \n"
                },
                {
                    "date": 1769775045257,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,9 +167,8 @@\n     Ktor-->>Client2: 200 OK<br/>{\"message\": \"Discount already applied\"}\n \n     Note over Client1, Client2: Both clients get success response<br/>but discount applied only once\n ```\n-\n ![alt text](Mermaid_1.png)\n \n ## Database Schema\n \n@@ -251,8 +250,4 @@\n 2. **Database Indexes**: Unique constraint serves dual purpose (integrity + performance)\n 3. **Transaction Isolation**: ACID compliance ensures data consistency\n 4. **Error Handling**: Graceful degradation with proper HTTP status codes\n 5. **Testing**: TestContainers ensure database behavior matches production\n-\n-\n-\n-![alt text](Mermaid_2.png)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1769775052328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,8 +120,9 @@\n     end\n     \n     Ktor-->>Client: JSON Array of ProductResponse\n ```\n+![alt text](Mermaid_2.png)\n \n ### PUT /products/{id}/discount\n \n Applies a discount to a product with concurrency safety and idempotency.\n"
                }
            ],
            "date": 1769774956643,
            "name": "Commit-0",
            "content": "# Architecture Documentation\n\n## System Design Overview\n\nThis Product API is built using **Ktor** (Kotlin web framework) with **PostgreSQL** as the persistent database. The architecture follows clean architecture principles with clear separation of concerns.\n\n### Key Components\n\n1. **Ktor Application Layer**: REST API endpoints with JSON serialization\n2. **Service Layer**: Business logic for price calculation and VAT handling\n3. **Repository Layer**: Database access with Exposed ORM\n4. **Database Layer**: PostgreSQL with connection pooling (HikariCP)\n\n### Technology Stack\n\n- **Framework**: Ktor 3.1.2 with Netty server\n- **Language**: Kotlin 2.2.20\n- **Database**: PostgreSQL with Exposed ORM\n- **Connection Pooling**: HikariCP\n- **Testing**: TestContainers for integration testing\n- **Serialization**: Kotlinx Serialization\n\n## Concurrency Control Strategy\n\nThe core requirement is to ensure **\"The same discount cannot be applied more than once to the same product — even under heavy concurrent load.\"**\n\n### Database-Level Concurrency Control\n\nWe implement concurrency control at the **database level** using PostgreSQL's ACID properties:\n\n```sql\n-- Unique constraint on product_discounts table\nCREATE UNIQUE INDEX product_discounts_unique_idx \nON product_discounts (product_id, discount_id);\n```\n\n### How It Works\n\n1. **Unique Constraint**: The `(product_id, discount_id)` combination must be unique\n2. **Atomic Operations**: All discount applications use database transactions\n3. **Idempotent Behavior**: Duplicate attempts return gracefully without side effects\n4. **Race Condition Prevention**: PostgreSQL handles concurrent insertions atomically\n\n### Idempotency Implementation\n\n```kotlin\nfun applyDiscount(productId: String, discount: Discount): Boolean = transaction {\n    try {\n        // Attempt to insert discount - will fail if already exists\n        ProductDiscounts.insert { ... }\n        true // Successfully applied\n    } catch (e: ExposedSQLException) {\n        if (e.message?.contains(\"unique constraint\") == true) {\n            false // Already exists - idempotent\n        } else {\n            throw e // Other error\n        }\n    }\n}\n```\n\n## Price Calculation Formula\n\nThe final price calculation implements the exact formula from requirements:\n\n**`finalPrice = basePrice × (1 - totalDiscount%) × (1 + VAT%)`**\n\n### Country VAT Rules\n\nThe system supports three countries with their respective VAT rates as specified in the requirements:\n\n| Country | VAT |\n|----------|-----|\n| Sweden | 25% |\n| Germany | 19% |\n| France | 20% |\n\nThese rates are implemented in the `VatService` and validated for each product request.\n\n### Compound Discount Calculation\n\nMultiple discounts are compounded using this formula:\n```\ntotalDiscountPercent = 1 - (1-d1/100) × (1-d2/100) × ... × (1-dn/100)\n```\n\nExample with 10% and 5% discounts:\n- `totalDiscount = 1 - (1-0.10) × (1-0.05) = 1 - 0.90 × 0.95 = 14.5%`\n\n## API Endpoints\n\n### GET /products?country={country}\n\nReturns all products for a specific country with calculated final prices.\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Ktor as Ktor API\n    participant Service as PriceCalculationService\n    participant VatService as VatService\n    participant Repository as ProductRepository\n    participant Database as PostgreSQL\n\n    Client->>Ktor: GET /products?country=Sweden\n    Ktor->>VatService: isCountrySupported(Sweden)\n    VatService-->>Ktor: true\n    Ktor->>Repository: findByCountry(Sweden)\n    Repository->>Database: SELECT products LEFT JOIN discounts WHERE country='Sweden'\n    Database-->>Repository: Product rows with discounts\n    Repository-->>Ktor: List<Product>\n    \n    loop For each product\n        Ktor->>Service: toProductResponse(product)\n        Service->>VatService: getVatRate(Sweden)\n        VatService-->>Service: 0.25\n        Service->>Service: calculateFinalPrice()\n        Note over Service: basePrice × (1-totalDiscount%) × (1+VAT%)\n        Service-->>Ktor: ProductResponse with finalPrice\n    end\n    \n    Ktor-->>Client: JSON Array of ProductResponse\n```\n\n### PUT /products/{id}/discount\n\nApplies a discount to a product with concurrency safety and idempotency.\n\n```mermaid\nsequenceDiagram\n    participant Client1 as Client 1\n    participant Client2 as Client 2\n    participant Ktor as Ktor API\n    participant Repository as ProductRepository\n    participant Database as PostgreSQL\n\n    Note over Client1, Client2: Concurrent discount application\n\n    par Concurrent Requests\n        Client1->>Ktor: PUT /products/laptop-1/discount<br/>{discountId: \"SALE2024\", percent: 20}\n    and\n        Client2->>Ktor: PUT /products/laptop-1/discount<br/>{discountId: \"SALE2024\", percent: 20}\n    end\n\n    par Repository Operations\n        Ktor->>Repository: applyDiscount(laptop-1, discount)\n        Repository->>Database: BEGIN TRANSACTION\n        Repository->>Database: INSERT INTO product_discounts<br/>(product_id='laptop-1', discount_id='SALE2024', percent=20)\n    and\n        Ktor->>Repository: applyDiscount(laptop-1, discount)\n        Repository->>Database: BEGIN TRANSACTION\n        Repository->>Database: INSERT INTO product_discounts<br/>(product_id='laptop-1', discount_id='SALE2024', percent=20)\n    end\n\n    Database-->>Repository: SUCCESS (First wins)\n    Database-->>Repository: UNIQUE CONSTRAINT VIOLATION (Second fails)\n\n    Repository-->>Ktor: true (discount applied)\n    Repository-->>Ktor: false (already exists)\n\n    Ktor->>Repository: findById(laptop-1)\n    Repository->>Database: SELECT with updated discounts\n    Database-->>Repository: Product with new discount\n    Repository-->>Ktor: Updated Product\n\n    Ktor-->>Client1: 200 OK<br/>{\"message\": \"Discount applied successfully\"}\n    Ktor-->>Client2: 200 OK<br/>{\"message\": \"Discount already applied\"}\n\n    Note over Client1, Client2: Both clients get success response<br/>but discount applied only once\n```\n\n## Database Schema\n\n### Tables\n\n**products**\n- `id` (VARCHAR, PRIMARY KEY): Product identifier\n- `name` (VARCHAR): Product name\n- `base_price` (DECIMAL): Price before discounts/VAT\n- `country` (VARCHAR): Country for VAT calculation\n\n**product_discounts**\n- `id` (BIGINT, AUTO_INCREMENT, PRIMARY KEY): Internal ID\n- `product_id` (VARCHAR, FOREIGN KEY): References products.id\n- `discount_id` (VARCHAR): Discount identifier for idempotency\n- `percent` (DECIMAL): Discount percentage\n- **UNIQUE CONSTRAINT**: `(product_id, discount_id)` ← **Concurrency Control**\n\n### Entity Relationship\n\n```mermaid\nerDiagram\n    products {\n        varchar id PK\n        varchar name\n        decimal base_price\n        varchar country\n    }\n    \n    product_discounts {\n        bigint id PK\n        varchar product_id FK\n        varchar discount_id\n        decimal percent\n    }\n    \n    products ||--o{ product_discounts : \"has many\"\n```\n\n## Error Handling\n\nThe API provides proper HTTP status codes:\n\n- **200 OK**: Successful operation\n- **400 Bad Request**: Invalid input (missing country, invalid discount%)\n- **404 Not Found**: Product doesn't exist\n- **500 Internal Server Error**: Database or system errors\n\n## Testing Strategy\n\n### Concurrency Test\n\nThe critical test `testConcurrentDiscountApplication()` simulates the exact requirement:\n\n```kotlin\n@Test\nfun testConcurrentDiscountApplication() = runBlocking {\n    val numberOfConcurrentRequests = 10\n    \n    // Launch 10 simultaneous requests to apply same discount\n    val concurrentRequests = (1..numberOfConcurrentRequests).map {\n        async {\n            client.put(\"/products/headphones-se/discount\") {\n                // Same discount request\n            }\n        }\n    }\n    \n    val responses = concurrentRequests.awaitAll()\n    \n    // Verify: All return 200 OK, but discount applied exactly once\n    // This proves concurrency safety at database level\n}\n```\n\n## Production Considerations\n\n1. **Connection Pooling**: HikariCP configured with proper limits\n2. **Database Indexes**: Unique constraint serves dual purpose (integrity + performance)\n3. **Transaction Isolation**: ACID compliance ensures data consistency\n4. **Error Handling**: Graceful degradation with proper HTTP status codes\n5. **Testing**: TestContainers ensure database behavior matches production\n"
        }
    ]
}